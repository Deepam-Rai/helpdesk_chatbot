import os
import secrets
import smtplib
import json
from datetime import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import List, Dict, Any
from actions.utils.utils_environment import *
from actions.constants import *
from .utils_database import *
import logging


logger = logging.getLogger(__name__)


def generate_otp(length: int = 4) -> str:
    """
    Generates random OTP of said length and returns as string
    :param length: length of OTP to return
    :return: OTP as string
    """
    otp = ''.join([str(secrets.randbelow(10)) for _ in range(length)])
    return otp


def send_email(receiver_email: str, subject: str = "", body: str = "") -> bool:
    """
    :param receiver_email:
    :param subject:
    :param body:
    :return:
    """
    sender_email = EMAIL_USERNAME
    sender_pass = EMAIL_PASSWORD
    if sender_email is None or sender_pass is None:
        missing_vars = [var for var in [EMAIL_USERNAME, EMAIL_PASSWORD] if var is None]
        raise EnvironmentError(f"Missing required environment variables for sending an email: {missing_vars}")
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = receiver_email
    msg['Subject'] = subject
    msg.attach(MIMEText(body, 'plain'))
    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(sender_email, sender_pass)
            server.send_message(msg)
            return True
    except Exception as e:
        logger.error(f"Failed to send email to {receiver_email}. ERROR: {e}")


def send_otp(receiver_email: str, receiver_name: str = "User") -> str:
    """
    Sends an otp to given user_email, and returns sent OTP.
    :param receiver_name: Added for personalization.
    :param receiver_email: To whom OTP is to be sent.
    :return: OTP sent to the user.
    """
    otp = generate_otp(length=OTP_LENGTH)
    sender_email = EMAIL_USERNAME
    send_email(
        receiver_email=receiver_email,
        subject="OTP",
        body=f"""
        Dear {receiver_name},
            Your OTP is: {otp}.
            Please do not share this One Time Password with anyone.
            If this was not you, please contact {sender_email} for clarification.
            [** This mail is generated by practice-project.
            If this was not you then someone has input wrong email and is breaking their head on their code right now.]
        
        Warm Regards.
        """
    )
    logger.debug(f"OTP sent to {receiver_email}")
    return otp


def get_previous_action_name(events: List[Dict[str, Any]], previous_count=-1, log=True):
    action_events = [
        event.get("name")
        for event in events
        if event.get("event") == "action" and event.get("name") != "action_listen"
    ]
    if log:
        logger.debug(f"events: {action_events}")
    return action_events[previous_count]


def get_second_previous_action_name(events: List[Dict[str, Any]]):
    action_events = [
        event.get("name")
        for event in events
        if event.get("event") == "action" and event.get("name") != "action_listen"
    ]
    return action_events[-2]


def get_timestamp():
    return f"{datetime.fromtimestamp(datetime.timestamp(datetime.now())).isoformat()}"


def get_timestamp_date():
    return f"{datetime.fromtimestamp(datetime.timestamp(datetime.now())).date().isoformat()}"


def get_timestamp_time():
    return f"{datetime.fromtimestamp(datetime.timestamp(datetime.now())).time().isoformat()}"


def log_fallback(tracker_event: dict):
    f"""
    Appends the tracker event into {NLU_FALLBACKS_FILE} file.
    :param tracker_event:
    :return:
    """
    log_file = APP_PATH / "logs" / NLU_FALLBACKS_FILE
    try:
        with open(log_file, 'r') as file:
            data = json.load(file)
        if isinstance(data, list):
            data.append(tracker_event)
        else:
            raise TypeError(f"{NLU_FALLBACKS_FILE} data is not a list, cannot append.")
    except FileNotFoundError:
        data = [tracker_event]

    with open(log_file, 'w') as file:
        json.dump(data, file, indent=4)
    logger.debug(f"New fallback logged in {NLU_FALLBACKS_FILE}")


def get_user_role(email: str) -> List[str]:
    """
    :param email: Role for whom role is to be fetched.
    :return: Returns role, or None if invalid email
    """
    user_details = retrieve_rows(
        TABLE_USERS,
        {
            COL_EMAIL: email,
        },
        SCHEMA_HELPDESK
    )
    role = None if len(user_details) < 1 else user_details[-1][COL_ROLE]
    return [role]


def get_users_list() -> List:
    f"""
    Fetches the rows from {TABLE_USERS} and returns.
    :return:
    """
    users = retrieve_rows(
        TABLE_USERS,
        {},
        SCHEMA_HELPDESK
    )
    return users
